# Protocol

* 默认情况下，定义的内容必须全部实现；后续学习部分实现。

![](media_011Protocol/001.png)



# 协议中的属性

![](media_011Protocol/002.png)



# 协议中的类型方法、属性、下标

* **class定义的类型方法、属性、下标只能被类使用；为了保证通用，协议必须使用static**

![](media_011Protocol/003.png)



# mutating

* mutating是为了修改**值类型（枚举、结构体）**本身
* 类不用mutating

![](media_011Protocol/005.png)

![](media_011Protocol/004.png)



# 协议中初始化器

![](media_011Protocol/006.png)

![](media_011Protocol/007.png)



# init、init?、init!

![](media_011Protocol/008.png)



# 协议继承协议

![](media_011Protocol/009.png)



# 协议组合

![](media_011Protocol/010.png)



# CaseIterable

![](media_011Protocol/011.png)



# CustomStringConvertible

![](media_011Protocol/012.png)



# Any、AnyObject

* AnyObject：类类型
* 创建一个任意类型的数组
  * `var arrs = Array<Any>()`
  * `var arrs = [Any]()`
* 创建任意类型的字典
  * `var dic = Dictionary<Any, Any>()`
  * `var dic = [Any: Any]()`

![](media_011Protocol/013.png)



# is、as?、as!、as

* is：用来判断类型
  * 包括：当前类、父类、协议等

```swift
var stu: Any = 10

(stu as? Student)?.study()
// 分析
// 第一个 as? 中的 ? 的意思：stu是任意类型，所以将其转换为Student类型，?表示转换可能成功或失败！！！
// 第二个 ? 的意思：转换后的结果是一个可选项，需要可选链来调用其study()方法！！！

(stu as! Student).study()
// 分析
// as! 强制转换，可能失败，容易崩溃！！！
// 后面省略一个 ! 表示隐式解包

var arr = [Any]()
arr.append(2 as Any)
// 分析
// 百分百确定类型，直接用as
```

![](media_011Protocol/014.png)



# X.self、X.Type、AnyObject、AnyClass、type(of: )

![](media_011Protocol/015.png)



* 类.self ：是一个元类型(metadata)指针，metadata存放着类型相关信息
* 等于 `对象指针指向地址的前八个字节（对象内存前八个字节存储的就是类型信息）`
* `X.self` 属于 `X.Type` 类型
* `AnyObject` 表示任意类类型
* `public typealias AnyClass = AnyObject.Type`
* `type(of: )` 获取对象的元类型(metadata)指针

```swift
var p = Person()
// 分析
// Person.self = 指向metadata的指针 = p对象内存的前八个字节
// Person.self 属于 Person.Type 类型

// AnyObject VS AnyObject.Type
var p1: Person = Person()
var p2: AnyObject = Person()

var pType1: Person.Type = Person.self
var pType2: AnyObject.Type = Person.self

// type(of: )
var p3 = Person()
var pType3 = type(of: p3)    // Person.self
```

![](media_011Protocol/016.png)



## 元类型(metadata) 的应用

```swift
// 方式一
var a1 = Animal()

// 方式二
var type = Aniaml.self
var a2 = type.init()

// 注意点：
// Animal 必须 required init() 
// 原因：因为可能传入的是子类的元类型，如何保证子类也有init方法，所以父类必须加上 required
```

![](media_011Protocol/017.png)



## Runtime查看元类型

* 纯Swift代码可以使用Runtime

* Swift文档中表示没有继承的类，就是基类；实际上还隐藏了一个基类`Swift._SwiftObject`
    * `class_getSuperclass(Person.self)`

![](media_011Protocol/018.png)



# Self

![](media_011Protocol/019.png)







