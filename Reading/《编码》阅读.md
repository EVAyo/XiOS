### 一、至亲密友

在直线距离上，通过灯的"闪"、"灭"来传递信息，从而引出了『摩尔斯电码』。



### 二、编码与组合

对『摩尔斯电码』的组成进行详细剖析。

SOS的摩尔斯码： `... --- ...`



![](media_conding/摩尔斯编码拆分.png)





### 三、布莱叶盲文与二进制码

路易斯-布莱叶（法国人，1809-1852）用六个点的凹凸（O、*）来表示信息。

```
1 O O 4
2 O O 5
3 O O 6
```



### 四、手电筒的剖析

原子（atom）：中子（neutron）、质子（proton）、电子（electron）



氢、氧、钠、氯都是元素。

水和盐是化合物（compound）。

盐水是混合物（mixture）,因为水和盐都各自保留着它们自己的性质。



电流产生的原因：一个原子中电子的数目一般情况下与质子数目相同，但在有些情况下，电子可能从原子中脱离，从而产生电流。



质子与电子都具有带电荷（charge）的性质。质子有一个正电荷（+），电子有一个负电荷（-），中子是中性的，因而不带电荷。当质子与电子数目相同时，他们是最稳定的。



电压：单位"伏"（V），因亚历山大-伏特（Alessandro Volta，1745-1827）伯爵名字命名，电压表征了电流做功的"势"（potential）,也就是电势能的大小，不管电池是否被连接的电路中，电压都是存在的。

电流（current）：它的计量单位是"安"（A），得名于安德烈-玛丽-安培（Andre Marie Ampere，1775-1836）。假如要获得 1 安的电流，就需要保证每秒有 6,240,000,000,000,000,000 个电子通过电路中的某一个点。

电阻：一般来说物质都倾向于阻拦电子的通过，单位是"欧姆"（Ω），得名于乔治-西蒙-欧姆（George Simon Ohm，1789-1854），他提出了著名的欧姆定律：

```
I = E / R
I 表示电路中的电流，E 表示电压（电动势），R 表示电阻
```



短路：用一小段铜线将电池正负极连接起来。此时电压1.5V除以一个非常小的电阻，也就是说电流将变得非常非常大，导线将会发热，因为电能被转化为了热能。这就是白帜灯发光的原理。白帜灯泡公认的发明者是美国的托马斯-阿尔瓦-爱迪生（Thomas Alva Edison,1847-1931）。



功率：它的计量单位是瓦特（W），得名于詹姆斯-瓦特（James Watt，1736-1819）。

```
P = E * I
P 表示功率，E 表示电压（电动势），I 表示电流
```



装逼运算：

1、普通电筒由两节电池串联，总电压3V，灯泡电阻一般为4Ω，计算出灯泡的功率？

```
第一步：计算电流 I
I = E / R 
I = 3V / 4Ω
I = 0.75A

第二步：计算功率 P
P = E * I
P = 3V * 0.75A
P = 2.25W
```

2、家里有100W的灯泡，中国家用电压一般为120V，计算该灯泡的电阻？

```
第一步：计算电流 I
P = E * I
I = P / E
I = 100W / 120V
I = 0.83A

第二步：计算电阻 R
I = E / R
R = E / I 
R = 120V / 0.83A
R = 144Ω
```



### 五、绕过拐角的通信

将地球作为一个巨大的导体，从而节省一个导线。



### 六、电报机和继电器

萨缪尔.芬利.布里斯.摩尔斯（Samuel Finley Breese Morse，1791）发明了 **电报机** 和 **莫尔斯码**。



电报（telegraph）：利用电磁现象。



### 七、我们的十个数字


### 八、十的替代品



### 九、二进制

#### 9.1、UPC条形码

##### 9.1.1、简介

![](media_conding/UPC-A条形码.png)

条形码，也叫作通用商品代码（UPC, Universal Product Code）。

UPC由30条不同宽度的垂直黑色条纹组成，它们的间隔宽度也不同，条纹下面有数字。

条形码的组成：黑细、黑粗、窄间隙、宽间隙

在UPC中黑色条纹有四种不同的宽度，以最细的黑色条纹为标准，分别还有最细条纹的两倍，三倍和四倍。

同样，间隙也有四种不同的宽度，最窄间隙、两倍、三倍和四倍。



##### 9.1.2、将图形转换为二进制

最细黑色条纹为1，最细间隙为0，对应的倍数分别为：11、111、111，00、000、000。（转换如下图）

![](media_conding/UPC条形码转为二进制.png)



| 最左边护线                                                   | 左边数字                                                     | 中间护线                                                     | 右边数字                                                     | 最右边护线               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ |
| 始终都是：101                                                | 0001101<br>0110001<br>0011001<br>0001101<br>0001101<br>0001101 | 始终都是：01010                                              | 1110010<br>1100110<br>1101100<br>1001110<br>1100110<br>1000100 | 始终都是：101            |
| 作用：帮助扫描仪确定代表单个比特的条和间隙的宽度是多少，并作为后续识别标准。 |                                                              | 作用：它是一个内置的检错码。如果扫描仪没有在对应的位置找到中间护线，它就无法破解UPC码。用来预防条形码被篡改或印错。 |                                                              | 作用：可以实现反向扫描。 |



**UPC对应的编码表**

|      | 左边的数字、奇码   | 右边的数字、偶码   |
| ---- | ------------------ | ------------------ |
| 数值 | 逻辑值（互为补码） | 逻辑值（互为补码） |
| 0    | 0001101            | 1110010            |
| 1    | 0011001            | 1100110            |
| 2    | 0010011            | 1101100            |
| 3    | 0111101            | 1000010            |
| 4    | 0100011            | 1011100            |
| 5    | 0110001            | 1001110            |
| 6    | 0101111            | 1010000            |
| 7    | 0111011            | 1000100            |
| 8    | 0110111            | 1001000            |
| 9    | 0001011            | 1110100            |



对照表格得出：`0  51000  01251  7`，正是条形码下方的数字。

> 解释
>
> 第一个数字0被称为数字系统符，0意味着这是一个常规的UPC。例如肉、农产品就是2，票券通常为5。
>
> 接下来的五个数表示制造商编码，51000就是Campbell公司的编码。
>
> 后面五个数表示这个公司的某种商品的编码。
>
> 最后一个数字被称为模校验字符（modulo check character），它是通过特定公式计算得出的。



**拓展：模校验字符如何计算？**

> 模拟编码： A  BCDEF  GHIJK
>
> 公式：`3 * (A+C+E+G+I+K) + (B+D+F+H+J)`，得到此值，再从这个值最近并且大于或等于它的一个10的整倍数中减去它，其结果称为 **模校验字符**（modulo check character）。
>
> 验证：
>
> 3 * (0 + 1 + 0 + 0 + 2 + 1) + (5 + 0 + 0 + 1 + 5) = 23
>
> 最近的数为30，所以 30 - 23 = 7。



##### 9.1.3、UPC条形码有哪些容错机制？

1. 中间护线
2. 左边的编码都是以0开头，以1结尾；右边的编码以1开头，以0结尾。
3. 奇偶校验
4. 最后一个数字被称为模校验字符，它是通过特定公式计算得出的。



##### 9.1.4、若反向扫描UPC码，会如何？

答案是显而易见的，肯定是可以的。

如果扫描仪解码的第一个数是符合偶校验（即7位编码中有偶数个1），扫描仪就会知道它是从右向左进行扫描UPC码，所以计算机会使用另一套表来解码，也就是将之前解密表顺序反过来。

例如：

之前左边码 0001101 = 0，现在左边码 1011000 = 0；

之前右边码 1110010 = 0，现在右边码 0100111 = 0。



#### 9.2、EAN条形码

参考文件： [EAN-13编码规则](http://www.barcodeisland.com/ean13.phtml)

本书的条形码就是EAN13条形码

![](media_conding/本书的条形码01.png)

我们日常生活中接触到的商品条形码，条码底部通常有13位数字，这种条形码又被称为**欧洲物品编码（EAN13）**，主要用于商场超市和零售店等。

EAN13条形码的第一位为前置码，最后一位为校验码。我们所看到的三对长于其他条码长度的直线段从左到右分别叫做起始符、中间分隔符和终止符。其中，起始符与中间分隔符之间的六位数字被称为左侧数据符，中间分隔符与校验码之间的五位数字被称为右侧数据符。生成条形码时便是将十进制数字信息或字符信息转化为二进制，使用空白处表示0、黑色表示1的规则，通过EAN13的编码表进行编码得出二进制数字串，进而将这串数字转换为条形码。



### 十、逻辑与开关

| 串联的开关（AND） |  0   |  1   |
| :---------------: | :--: | :--: |
|         0         |  0   |  0   |
|         1         |  0   |  1   |

| 并联的开关（OR） |  0   |  1   |
| :--------------: | :--: | :--: |
|        0         |  0   |  1   |
|        1         |  1   |  1   |



### 十一、门

继电器：开关闭合，灯亮；开关不闭合，灯灭。

双掷继电器p116：

反向器p124：与继电器相反，开关闭合，灯灭；开关不闭合，灯亮。能够将0低电平转换为1高电平，反之亦然。

![](media_conding/LogicGate/NOT_ANSI.svg)



####  11.1、逻辑门整体分类 --- [维基百科-逻辑门](https://zh.wikipedia.org/wiki/邏輯閘)

**『与、或、非』三大类划分**

| ![](media_conding/LogicGate/AND_ANSI.svg)与门           | ![img](media_conding/LogicGate/OR_ANSI.svg)或门              | ![img](media_conding/LogicGate/NOT_ANSI.svg)非门    |
| ------------------------------------------------------- | ------------------------------------------------------------ | --------------------------------------------------- |
| ![img](media_conding/LogicGate/NAND_ANSI.svg)与非门     | ![img](media_conding/LogicGate/NOR_ANSI.svg)或非门           | ![img](media_conding/LogicGate/Buffer_ANSI.svg)是门 |
| ![img](media_conding/LogicGate/NIMPLY_ANSI.svg)蕴含非门 | ![img](media_conding/LogicGate/XOR_ANSI.svg)异或门           |                                                     |
|                                                         | ![img](media_conding/LogicGate/XNOR_ANSI.svg)同或门/反异或门 |                                                     |
|                                                         | ![img](media_conding/LogicGate/IMPLY_ANSI.svg)蕴含门         |                                                     |

**分别具体介绍**

| 类型              | ANSI及IEEE标准                               | 逻辑函数                                                     | 真值表                                             |
| ----------------- | -------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| AND / 与门        | ![](media_conding/LogicGate/AND_ANSI.svg)    | ![](media_conding/LogicGate/AND_LogicFunc.svg)               | ![](media_conding/LogicGate/AND_TruthTable.png)    |
| OR / 或门         | ![](media_conding/LogicGate/OR_ANSI.svg)     | ![](media_conding/LogicGate/OR_LogicFunc.svg)                | ![](media_conding/LogicGate/OR_TruthTable.png)     |
| NOT / 非门        | ![](media_conding/LogicGate/NOT_ANSI.svg)    | ![](media_conding/LogicGate/NOT_LogicFunc.svg)               | ![](media_conding/LogicGate/NOT_TruthTable.png)    |
| NAND / 与非门     | ![](media_conding/LogicGate/NAND_ANSI.svg)   | ![](media_conding/LogicGate/NAND_LogicFunc.svg)              | ![](media_conding/LogicGate/NAND_TruthTable.png)   |
| NOR / 或非门      | ![](media_conding/LogicGate/NOR_ANSI.svg)    | ![](media_conding/LogicGate/NOR_LogicFunc.svg)               | ![](media_conding/LogicGate/NOR_TruthTable.png)    |
| XOR / 异或门      | ![](media_conding/LogicGate/XOR_ANSI.svg)    | ![](media_conding/LogicGate/XOR_LogicFunc.svg)               | ![](media_conding/LogicGate/XOR_TruthTable.png)    |
| XNOR / 同或门     | ![](media_conding/LogicGate/XNOR_ANSI.svg)   | ![](media_conding/LogicGate/XNOR_LogicFunc01.svg) / ![](media_conding/LogicGate/XNOR_LogicFunc02.svg) | ![](media_conding/LogicGate/XNOR_TruthTable.png)   |
| BUF / 是门        | ![](media_conding/LogicGate/Buffer_ANSI.svg) | ![](media_conding/LogicGate/Buffer_LogicFunc.svg)            | ![](media_conding/LogicGate/Buffer_TruthTable.png) |
| IMPLY / 蕴含门    | ![](media_conding/LogicGate/IMPLY_ANSI.svg)  | ![](media_conding/LogicGate/IMPLY_LogicFunc.svg)             | ![](media_conding/LogicGate/IMPLY_TruthTable.png)  |
| NIMPLY / 蕴含非门 | ![](media_conding/LogicGate/NIMPLY_ANSI.svg) | ![](media_conding/LogicGate/NIMPLY_LogicFunc01.svg) / ![](media_conding/LogicGate/NIMPLY_LogicFunc02.svg) | ![](media_conding/LogicGate/NIMPLY_TruthTable.png) |



### 十二、二进制加法器

#### 12.1、二进制加法表

|  +   |  00  |  01  |
| :--: | :--: | :--: |
|  00  |  00  |  01  |
|  01  |  01  |  10  |



#### 12.2、加法位

| 加法位 |  0   |  1   |
| :----: | :--: | :--: |
|   0    |  0   |  1   |
|   1    |  1   |  0   |

联想到 **异或门**，它是由 `或门、与非门、与门` 组成。

<img src="media_conding/异或门逻辑图.png" style="zoom:67%;" />

![](media_conding/LogicGate/XOR_TruthTable.png)

#### 12.3、进位位

| 进位位 |  0   |  1   |
| :----: | :--: | :--: |
|   0    |  0   |  0   |
|   1    |  0   |  1   |

联想到 **与门**

![](media_conding/LogicGate/AND_TruthTable.png)

#### 12.4、半加器

将 **与门** 和 **异或门** 连在一起来计算两个二进制数（即A和B）的和：

![](media_conding/Half_Adder.svg)



<img src="media_conding/半加器逻辑图.png" style="zoom:67%;" />

> - 和：记作 *S*，来自对应的英语 Sum；
> - 进位：记作 *C*，来自对应的英语 Carry一位的数字。

之所以叫**半加器**是有原因的，因为它没有做到的是将之前一次的加法可能产生的进位位纳入下一次运算。

#### 12.5、全加器

对三个二进制数进行加法运算，需要将 **两个半加器和一个或门** 做如下连接，这就是 **全加器** ：

<img src="media_conding/半加器组合成全加器.png" style="zoom:67%;" />

<img src="media_conding/全加器逻辑图.png" style="zoom:67%;" />

#### 12.6、八位加法器



<img src="media_conding/八位二进制加法器01.png" style="zoom:50%;" />

<img src="media_conding/八位二进制加法器02.png" style="zoom:50%;" />

<img src="media_conding/八位二进制加法器03.png" style="zoom: 67%;" />

**问：共需要多少个继电器？**

每个与门、或门和与非门都需要两个继电器，因此一个异或门就包含6个继电器。

一个半加器是由一个异或门和一个与门组成的，因此一个半加器就需要8个继电器。

每个全加器由两个半加器和一个或门组成，所以一个全加器就需要18个继电器。

一个8位二进制加法器由8个全加器组成，所以总共需要144个继电器。



**继电器与晶体管**

如今，计算机已经不再使用**继电器**了！尽管它曾经被使用过。

第一台数字计算机在20世纪30年代被建造完成，当时所使用的就是**继电器**，后来也使用过**真空管**。

今天的计算机使用的是**晶体管**。

在被用到计算机中时，**晶体管**的工作方式与**继电器**基本相同。

但是**晶体管**要比**继电器**计算速度更快，体积更小，而且噪声更弱、耗能也更低，而且更便宜。

搭建一个**8位加法器仍然需要144个晶体管**，但是电路却是极小的。



### 十三、如何实现减法

#### 13.1、原码、反码、补码





### 十四、





### 十五、字节与十六进制



#### 15.1、**为什么计算机存储单元是八位？（或者：为什么一个字节是8位？）**

原因：

1. 其实以前也有过4位，6位或7位为一byte的标准，IBM 701（36位字长，18位byte）、IBM 702（7位字长，7位byte）、CDC 6600（60位字长，12位byte）等等。
2. ASCII编码：American Standard Code for information Interchange，美国信息交换标准码。那为什么是8位呢？**因为8位可以存储所有ASCII所有字符（这是它包含8bits的初衷）**。因为这套编码系统是美国统一的标准，对美国人来说；所有字符包括单词，标点符号都全部都囊括进了这128（0~127）个字符，美国人用完全就够了。



#### 15.2、**bit & Byte**

bit：

> * 计算机中的最小存储单元
> * 存储内容总是0或1
> * 所有二进制状态的实体都可以使用1bit表示
> * 8bits组成1byte
> * 不能够单独寻址

Byte：

> * 1byte包含8bits
> * 可以存储所有ASCII所有字符（这是它包含8bits的初衷）
> * 十进制整数范围[-128,127]或[0, 255]
> * 最小的可寻址存储单元



#### 15.3、进制

11110000 TWO

2312 FOUR

266 EIGHT

182 TEN

B6 HEX













