### 一、至亲密友

在直线距离上，通过灯的"闪"、"灭"来传递信息，从而引出了『摩尔斯电码』。



### 二、编码与组合

对『摩尔斯电码』的组成进行详细剖析。

SOS的摩尔斯码： `... --- ...`



![](media_conding/摩尔斯编码拆分.png)





### 三、布莱叶盲文与二进制码

路易斯-布莱叶（法国人，1809-1852）用六个点的凹凸（O、*）来表示信息。

```
1 O O 4
2 O O 5
3 O O 6
```



### 四、手电筒的剖析

原子（atom）：中子（neutron）、质子（proton）、电子（electron）



氢、氧、钠、氯都是元素。

水和盐是化合物（compound）。

盐水是混合物（mixture）,因为水和盐都各自保留着它们自己的性质。



电流产生的原因：一个原子中电子的数目一般情况下与质子数目相同，但在有些情况下，电子可能从原子中脱离，从而产生电流。



质子与电子都具有带电荷（charge）的性质。质子有一个正电荷（+），电子有一个负电荷（-），中子是中性的，因而不带电荷。当质子与电子数目相同时，他们是最稳定的。



电压：单位"伏"（V），因亚历山大-伏特（Alessandro Volta，1745-1827）伯爵名字命名，电压表征了电流做功的"势"（potential）,也就是电势能的大小，不管电池是否被连接的电路中，电压都是存在的。

电流（current）：它的计量单位是"安"（A），得名于安德烈-玛丽-安培（Andre Marie Ampere，1775-1836）。假如要获得 1 安的电流，就需要保证每秒有 6,240,000,000,000,000,000 个电子通过电路中的某一个点。

电阻：一般来说物质都倾向于阻拦电子的通过，单位是"欧姆"（Ω），得名于乔治-西蒙-欧姆（George Simon Ohm，1789-1854），他提出了著名的欧姆定律：

```
I = E / R
I 表示电路中的电流，E 表示电压（电动势），R 表示电阻
```



短路：用一小段铜线将电池正负极连接起来。此时电压1.5V除以一个非常小的电阻，也就是说电流将变得非常非常大，导线将会发热，因为电能被转化为了热能。这就是白帜灯发光的原理。白帜灯泡公认的发明者是美国的托马斯-阿尔瓦-爱迪生（Thomas Alva Edison,1847-1931）。



功率：它的计量单位是瓦特（W），得名于詹姆斯-瓦特（James Watt，1736-1819）。

```
P = E * I
P 表示功率，E 表示电压（电动势），I 表示电流
```



装逼运算：

1、普通电筒由两节电池串联，总电压3V，灯泡电阻一般为4Ω，计算出灯泡的功率？

```
第一步：计算电流 I
I = E / R 
I = 3V / 4Ω
I = 0.75A

第二步：计算功率 P
P = E * I
P = 3V * 0.75A
P = 2.25W
```

2、家里有100W的灯泡，中国家用电压一般为120V，计算该灯泡的电阻？

```
第一步：计算电流 I
P = E * I
I = P / E
I = 100W / 120V
I = 0.83A

第二步：计算电阻 R
I = E / R
R = E / I 
R = 120V / 0.83A
R = 144Ω
```



### 五、绕过拐角的通信

将地球作为一个巨大的导体，从而节省一个导线。



### 六、电报机和继电器

萨缪尔.芬利.布里斯.摩尔斯（Samuel Finley Breese Morse，1791）发明了 **电报机** 和 **莫尔斯码**。



电报（telegraph）：利用电磁现象。



### 七、我们的十个数字


### 八、十的替代品



### 九、二进制

#### 9.1、UPC条形码

##### 9.1.1、简介

![](media_conding/UPC-A条形码.png)

条形码，也叫作通用商品代码（UPC, Universal Product Code）。

UPC由30条不同宽度的垂直黑色条纹组成，它们的间隔宽度也不同，条纹下面有数字。

条形码的组成：黑细、黑粗、窄间隙、宽间隙

在UPC中黑色条纹有四种不同的宽度，以最细的黑色条纹为标准，分别还有最细条纹的两倍，三倍和四倍。

同样，间隙也有四种不同的宽度，最窄间隙、两倍、三倍和四倍。



##### 9.1.2、将图形转换为二进制

最细黑色条纹为1，最细间隙为0，对应的倍数分别为：11、111、111，00、000、000。（转换如下图）

![](media_conding/UPC条形码转为二进制.png)



| 最左边护线                                                   | 左边数字                                                     | 中间护线                                                     | 右边数字                                                     | 最右边护线               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ |
| 始终都是：101                                                | 0001101<br>0110001<br>0011001<br>0001101<br>0001101<br>0001101 | 始终都是：01010                                              | 1110010<br>1100110<br>1101100<br>1001110<br>1100110<br>1000100 | 始终都是：101            |
| 作用：帮助扫描仪确定代表单个比特的条和间隙的宽度是多少，并作为后续识别标准。 |                                                              | 作用：它是一个内置的检错码。如果扫描仪没有在对应的位置找到中间护线，它就无法破解UPC码。用来预防条形码被篡改或印错。 |                                                              | 作用：可以实现反向扫描。 |



**UPC对应的编码表**

|      | 左边的数字、奇码   | 右边的数字、偶码   |
| ---- | ------------------ | ------------------ |
| 数值 | 逻辑值（互为补码） | 逻辑值（互为补码） |
| 0    | 0001101            | 1110010            |
| 1    | 0011001            | 1100110            |
| 2    | 0010011            | 1101100            |
| 3    | 0111101            | 1000010            |
| 4    | 0100011            | 1011100            |
| 5    | 0110001            | 1001110            |
| 6    | 0101111            | 1010000            |
| 7    | 0111011            | 1000100            |
| 8    | 0110111            | 1001000            |
| 9    | 0001011            | 1110100            |



对照表格得出：`0  51000  01251  7`，正是条形码下方的数字。

> 解释
>
> 第一个数字0被称为数字系统符，0意味着这是一个常规的UPC。例如肉、农产品就是2，票券通常为5。
>
> 接下来的五个数表示制造商编码，51000就是Campbell公司的编码。
>
> 后面五个数表示这个公司的某种商品的编码。
>
> 最后一个数字被称为模校验字符（modulo check character），它是通过特定公式计算得出的。



**拓展：模校验字符如何计算？**

> 模拟编码： A  BCDEF  GHIJK
>
> 公式：`3 * (A+C+E+G+I+K) + (B+D+F+H+J)`，得到此值，再从这个值最近并且大于或等于它的一个10的整倍数中减去它，其结果称为 **模校验字符**（modulo check character）。
>
> 验证：
>
> 3 * (0 + 1 + 0 + 0 + 2 + 1) + (5 + 0 + 0 + 1 + 5) = 23
>
> 最近的数为30，所以 30 - 23 = 7。



##### 9.1.3、UPC条形码有哪些容错机制？

1. 中间护线
2. 左边的编码都是以0开头，以1结尾；右边的编码以1开头，以0结尾。
3. 奇偶校验
4. 最后一个数字被称为模校验字符，它是通过特定公式计算得出的。



##### 9.1.4、若反向扫描UPC码，会如何？

答案是显而易见的，肯定是可以的。

如果扫描仪解码的第一个数是符合偶校验（即7位编码中有偶数个1），扫描仪就会知道它是从右向左进行扫描UPC码，所以计算机会使用另一套表来解码，也就是将之前解密表顺序反过来。

例如：

之前左边码 0001101 = 0，现在左边码 1011000 = 0；

之前右边码 1110010 = 0，现在右边码 0100111 = 0。



#### 9.2、EAN条形码

参考文件： [EAN-13编码规则](http://www.barcodeisland.com/ean13.phtml)

本书的条形码就是EAN13条形码

![](media_conding/本书的条形码01.png)

我们日常生活中接触到的商品条形码，条码底部通常有13位数字，这种条形码又被称为**欧洲物品编码（EAN13）**，主要用于商场超市和零售店等。

EAN13条形码的第一位为前置码，最后一位为校验码。我们所看到的三对长于其他条码长度的直线段从左到右分别叫做起始符、中间分隔符和终止符。其中，起始符与中间分隔符之间的六位数字被称为左侧数据符，中间分隔符与校验码之间的五位数字被称为右侧数据符。生成条形码时便是将十进制数字信息或字符信息转化为二进制，使用空白处表示0、黑色表示1的规则，通过EAN13的编码表进行编码得出二进制数字串，进而将这串数字转换为条形码。



